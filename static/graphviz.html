<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAG Visualization with D3.js</title>
    <style>
        body {
            background-color: black;
            margin: 0; /* Optional: removes default margin */
            padding: 0; /* Optional: removes default padding */
        }

        text {
            font-size: 16px;
            fill: white; /* Ensure the text is visible */
            text-anchor: middle; /* Center the text horizontally */
        }

        .node circle {
            stroke: #000;
            stroke-width: 1.5px;
        }

        .node text {
            font: 12px sans-serif;
            pointer-events: none;
        }

        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            marker-end: url(#arrowhead);
        }
    </style>
</head>
<body>
    <div style="text-align: center; margin-bottom: 10px;">
        <input type="text" id="search" placeholder="Search for a node or edge...">
        <button onclick="searchGraph()">Search</button>
    </div>
    <svg id="mySvg" width="960" height="600">
        <rect width="960" height="600" fill="none" stroke="white"></rect> <!-- Bounding box -->
        <g id="panGroup">
            <!-- All pan/zoomable content should go here -->
        </g>
        <text id="centerCoords" x="50%" y="50%">480, 300</text> <!-- Center coordinates -->
    </svg>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = 960;
        const height = 600;

        const full_node_count = 1000;
        const full_edge_count = 3000;

        const inital_nodecount = 100;
        const initial_degree = 5;

        var allNodes = [], allLinks = [], allNbrsById = {}
        function initFullGraph() {
            allNodes = Array.from({ length: full_node_count }, (_, i) => ({ id: `n${i}` }));
            allLinks = Array.from({ length: full_edge_count }, () => {
                src = Math.floor(Math.random() * (full_node_count-1))
                tgt = Math.floor(Math.random() * (full_node_count-1))
                if (src > tgt) {
                    temp = src;src = tgt; tgt = temp;
                }
                tgt = tgt + 1

                id = `e_${src}_${tgt}`
	        retval = ({
                    id:     id,
                    source: allNodes[src],
                    target: allNodes[tgt]
                })
                return retval
            });
            allNbrsById = {}
            allLinks.forEach(link => {
                if (!allNbrsById[link.source.id]) {
                    allNbrsById[link.source.id] = [];
                }
                if (!allNbrsById[link.target.id]) {
                    allNbrsById[link.target.id] = [];
                }
                allNbrsById[link.source.id].push({l: link, n: link.target});
                allNbrsById[link.target.id].push({l: link, n: link.source});
            })
        }
        initFullGraph();

        let loadedNodes = {};         // Store currently loaded nodes.  Type: NodeId -> Node
        let loadedLinksAdjlist = {};  // Store currently loaded links.  Type: Nbr1Id -> (Nbr2Id -> Link)
        let loadedLinks = {}          //                                Type: EdgeId -> Link
        function addToLoadedNodes(node){
            if (!loadedNodes[node.id]) {
                loadedNodes[node.id] = node;  // Copy nodes to loadedNodes

                // Initialize an empty array in loadedLinksAdjlist for each node
                if (!loadedLinksAdjlist[node.id]) {
                    loadedLinksAdjlist[node.id] = {};
                }
            }
        }

        function addToLoadedLinks(link){
            if (!loadedNodes[link.source.id]) {
                addToLoadedNodes(link.source)
            }
            loadedLinksAdjlist[link.source.id][link.target.id] = link;

            if (!loadedNodes[link.target.id]) {
                addToLoadedNodes(link.target)
            }
            loadedLinksAdjlist[link.target.id][link.source.id] = link;

            loadedLinks[link.id] = link
        }

        function loadInitialGraph(seedNodes = []) {
            let nodeQueue = [...seedNodes];  // Initialize nodeQueue with seed nodes
            let nodesProcessed = 0;

            while (nodeQueue.length > 0 || (nodesProcessed < inital_nodecount && Object.keys(loadedNodes).length < Object.keys(allNodes).length)) {
                // If the queue is empty and we haven't processed 'inital_nodecount' nodes, add arbitrary nodes
                if (nodeQueue.length === 0) {
                    chosenIndex = Math.floor(Math.random() * allNodes.length);
                    for (let i = 0;i < allNodes.length; i++) {
                        curChosenIndex = (chosenIndex+i) % allNodes.length
                        curChosen = allNodes[curChosenIndex]
                        if (!loadedNodes[curChosen.id]) {
                            nodeQueue.push(curChosen);
                            break;
                        }
                    }
                }

                let currentNode = nodeQueue.shift();  // Get the next node from the queue

                // Skip if the node is already loaded
                if (loadedNodes[currentNode.id]) continue;

                // Add the current node to the loaded list
                addToLoadedNodes(currentNode);
                nodesProcessed++;

                // Get the neighbors of the current node from the adjacency list
                let neighbors = allNbrsById[currentNode.id];

                // Split neighbors into already loaded and not yet loaded
                let alreadyLoadedNeighbors = neighbors.filter(nbhood => loadedNodes[nbhood.n.id]);
                let notLoadedNeighbors = neighbors.filter(nbhood => !loadedNodes[nbhood.n.id]);
                permute(notLoadedNeighbors);

                // Add all already loaded neighbors
                alreadyLoadedNeighbors.forEach(nbhood => addToLoadedLinks(nbhood.l));

                // Calculate the remaining capacity
                let remainingCapacity = inital_nodecount - nodesProcessed;

                // Add not-yet-loaded neighbors, only up to the remaining capacity
                let selectedNotLoadedNeighbors = notLoadedNeighbors.slice(0, Math.min(initial_degree, remainingCapacity));
                selectedNotLoadedNeighbors.forEach(nbhood => {
                    addToLoadedNodes(nbhood.n);
                    addToLoadedLinks(nbhood.l);
                    nodeQueue.push(nbhood.n);
                });
            }
        }

        loadInitialGraph();

        const mySvg = document.getElementById('mySvg');
        const panGroup = document.getElementById('panGroup');
        const text = document.getElementById('centerCoords');

        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                panGroup.setAttribute("transform", event.transform);
                updateCenterCoordinates(event.transform);
            });

        const svg = d3.select(mySvg)
            .attr("width", width)
            .attr("height", height)
            .style("position", "relative")  // Ensure SVG positioning
            .call(zoom)
            .append("g");

        // Append a rectangle as a bounding box
        //svg.append("rect")
        //    .attr("x", 0)
        //    .attr("y", 0)
        //    .attr("width", width)
        //    .attr("height", height)
        //    .attr("fill", "none")
        //    .attr("stroke", "black")
        //    .attr("stroke-width", 2);  // Adjust stroke width as needed

        svg.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "-0 -5 10 10")
            .attr("refX", 13)
            .attr("refY", 0)
            .attr("orient", "auto")
            .attr("markerWidth", 3)
            .attr("markerHeight", 3)
            .attr("xoverflow", "visible")
            .append("svg:path")
            .attr("d", "M 0,-5 L 10 ,0 L 0,5")
            .attr("fill", "#999")
            .style("stroke", "none");

        const simulation = d3.forceSimulation(Object.values(loadedNodes))
            .force(
                "link",
                d3.forceLink(Object.values(loadedLinks))
                  .id(d => d.id)
                  .distance(50))
            .force("charge", d3.forceManyBody().strength(-20))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide(15))
            .on("tick", ticked);

        const link = d3.select(panGroup).append("g")
                          .attr("class", "links")
                        .selectAll("line")
                          .data(Object.values(loadedLinks))
                          .enter()
                          .append("line")
                            .attr("stroke-width", 2)
                            .attr("class", "link")
                            .on("click", function(event, d) {
                                selectEdge(d);
                            });

        const node = d3.select(panGroup).append("g")
                          .attr("class", "nodes")
                        .selectAll("g")
                          .data(Object.values(loadedNodes))
                          .enter().append("g")
                            .attr("class", "node")
                            .on("click", function(event, d) {
                                selectNode(d);
                            });

        node.append("circle")
            .attr("fill", "lightgreen")
            .attr("r", 10);

        node.append("text")
              .attr("x", 0)
              .attr("y", 0)
              .attr("dy", ".35em")
              .attr("text-anchor", "middle")
              .style("font-size", "0.33em")
              .text(d => d.id)
              .attr("fill", "deepblue");  // Default text color

        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);

            updateCenterCoordinates();
        }

        const updateCenterCoordinates = (transform = null) => {
            if (transform == null) {
                return
            }
            const svgRect = mySvg.getBoundingClientRect();

            const [centerX, centerY] = transform.invert([svgRect.width / 2, svgRect.height / 2]);

            text.textContent = `${Math.round(centerX)}, ${Math.round(centerY)}`;
        };
        window.addEventListener('resize', updateCenterCoordinates);
        updateCenterCoordinates(); // Initial call to set coordinates

        function searchGraph() {
            const searchTerm = document.getElementById('search').value;
            const foundNode = loadedNodes[searchTerm];
            if (foundNode) {
                selectNode(foundNode);
            } else {
                const foundLink = loadedLinks[searchTerm];
                if (foundLink) {
                    selectEdge(foundLink);
                } else {
                    alert("Node or link not found");
                }
            }
        }
        let selectedNode = null; // Keep track of the currently selected node
        let selectedEdge = null; // Keep track of the currently selected link
        let selectedNeighbors = {}; // Keep track of the selected neighbors

        function colorNode(node, circleColor, textColor) {
            nbrElement = d3.selectAll(".node").filter(d => d === node)
            nbrElement.select("circle").attr("fill", circleColor);
            nbrElement.select("text").attr("stroke", textColor).attr("stroke-width", "1px").attr("font-size", "11px")
        }

        function colorEdge(link, strokeColor) {
            // Highlight the selected link in blue
            edgeElement = d3.selectAll(".link").filter(d => d == link)
            edgeElement.style("stroke", strokeColor);
        }

        function deSelectNbrs() {
                Object.values(selectedNeighbors).forEach(ls => {
                    nbr = ls[0]
                    nbrEdge = ls[1]
                    colorNode(nbr, "lightgreen", "DarkBlue")
                    colorEdge(nbrEdge, "lightgray")
                });
                selectedNeighbors = {};
        }

        function deSelectNode() {
            if (selectedNode) {
                // Reset the selected node's text color to DarkBlue
                colorNode(selectedNode, "lightgreen", "DarkBlue")
                selectedNode = null; // Clear the selected node

                // Reset the color of edges connected to the previously selected node to light gray
                d3.selectAll(".link")
                    .attr("stroke", "lightgray");
            }
        }

        function deSelectEdge() {
            if (selectedEdge) {
                colorEdge(selectedEdge, "lightgray");
                colorNode(selectedEdge.source, "lightgreen", "DarkBlue")
                colorNode(selectedEdge.target, "lightgreen", "DarkBlue")
                selectedEdge = null; // Clear the selected link
            }
        }

        function selectNbr(nbrEdge, selectedNeighbor) {
            colorEdge(nbrEdge, "crimson");
            colorNode(selectedNeighbor, "lightyellow", "black");
            selectedNeighbors[selectedNeighbor.id] = [selectedNeighbor, nbrEdge];
        }

        function showBoundingBox() {
            // Calculate the bounding box and zoom to show all neighbors
            setTimeout(() => {
                let xs = new Set();
                let ys = new Set();

                if (selectedNode) {
                    xs.add(selectedNode.x)
                    ys.add(selectedNode.y)
                }

                if (selectedEdge) {
                    xs.add(selectedEdge.source.x).add(selectedEdge.target.x)
                    ys.add(selectedEdge.source.y).add(selectedEdge.target.y)
                }

                Object.values(selectedNeighbors).forEach(ls => {
                    nbr = ls[0]
                    xs.add(nbr.x)
                    ys.add(nbr.y)
                });

                if (xs.size >= 1) {
                    x0 = d3.min(xs), y0 = d3.min(ys), x1=d3.max(xs), y1 = d3.max(ys)

                    const boxWidth = Math.max(0.1, x1 - x0);
                    const boxHeight = Math.max(0.1, y1 - y0);

                    const scale = 0.8*Math.min(width / boxWidth, height / boxHeight);

                    const translateX = (width - scale * (x0 + x1)) / 2;
                    const translateY = (height - scale * (y0 + y1)) / 2;


                    const transform = d3.zoomIdentity
                        .translate(translateX, translateY)
                        .scale(scale);

                    d3.select(mySvg).transition()
                        .duration(1500)
                        .call(
                            zoom.transform,
                            transform
                        ).on("end", () => {
                            updateCenterCoordinates(transform);
                        });
                }
            }, 1000);
        }

        function selectNode(nodeData) {
            toggleCase = (nodeData == selectedNode)

            // De-select any previously selected node or link
            deSelectNode();
            deSelectEdge();

            // Clear the selected neighbors set and reset their colors
            deSelectNbrs();

            if (toggleCase) {
                return;
            }

            // Highlight the selected node in pink/red.
            colorNode(nodeData, "pink", "red")
            selectedNode = nodeData;

            // Identify neighbors and add them to the selectedNeighbors set
            Object.values(loadedLinksAdjlist[nodeData.id]).forEach(link => {
                if (link.source === nodeData) {
                    selectNbr(link, link.target);
                } else if (link.target === nodeData) {
                    selectNbr(link, link.source);
                }
            });

            // Apply stronger repulsive force limited to a certain distance for neighbors
            simulation
                .force(
                    "link",
                    d3.forceLink(Object.values(loadedLinksAdjlist[nodeData.id]))
                        .id(d => d.id)
                        .distance(50))
                .force(
                    "charge",
                    d3.forceManyBody()
                         .strength(-600)
                        //  .strength(d => d.id in selectedNeighbors ? -600 : -200)  // 3x repulsive force for neighbors
                        //  .distanceMax(d => d.id in selectedNeighbors ? 100 : Infinity)) // Limit force to 100 units for neighbors
                )
                .alpha(1)
                .restart();

            showBoundingBox();
        }

        function selectEdge(edgeData) {
            toggleCase = (edgeData == selectedEdge)

            // De-select any previously selected node or link
            deSelectNode();
            deSelectEdge();

            // Clear the selected neighbors set and reset their colors
            deSelectNbrs()

            if (toggleCase) {
                return;
            }

            // Highlight the selected link in blue and its nodes pink/red.
            colorEdge(edgeData, "crimson");
            colorNode(edgeData.source, "pink", "red")
            colorNode(edgeData.target, "pink", "red")
            selectedEdge = edgeData;

            // Identify all neighbors of the source and target nodes and add them to the selectedNeighbors set
            nbrLinks = [edgeData]
            Object.entries(loadedLinksAdjlist[edgeData.source.id]).forEach(([altTargetId, link]) => {
                if (altTargetId != edgeData.target.id) {
                    selectNbr(link, loadedNodes[altTargetId]);
                    nbrLinks.push(link);
                }
            })
            Object.entries(loadedLinksAdjlist[edgeData.target.id]).forEach(([altSourceId, link]) => {
                if (altSourceId != edgeData.source.id) {
                    selectNbr(link, loadedNodes[altSourceId]);
                    nbrLinks.push(link);
                }
            })

            // Apply stronger repulsive force limited to a certain distance for neighbors
            simulation
                .force(
                    "link",
                    d3.forceLink(nbrLinks)
                        .id(d => d.id)
                        .distance(d => d.source.id in selectedNeighbors || d.target.id in selectedNeighbors ? 50 : 80)
                        )
                .force(
                    "charge",
                    d3.forceManyBody()
                        .strength(-20)
                        //  .strength(d => d.id in selectedNeighbors ? -200)  // 3x repulsive force for neighbors
                        //  .distanceMax(d => d.id in selectedNeighbors 100 : Infinity) // Limit force to 100 units for neighbors
                    )
                .alpha(1)
                .restart();

            showBoundingBox();
        }

        function permute(array) {
          let currentIndex = array.length;

          // While there remain elements to shuffle...
          while (currentIndex != 0) {

            // Pick a remaining element...
            let randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            // And swap it with the current element.
            [array[currentIndex], array[randomIndex]] = [
              array[randomIndex], array[currentIndex]];
          }
        }

        selectNode(Object.values(loadedNodes)[0])

    </script>
</body>
</html>

